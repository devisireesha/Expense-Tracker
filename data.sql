CREATE TABLE IF NOT EXISTS Users (
    UserID INT GENERATED BY DEFAULT AS IDENTITY(NO CACHE) PRIMARY KEY,
    Username VARCHAR(100) NOT NULL,
    Password VARCHAR(255) NOT NULL,
    Email VARCHAR(255) UNIQUE NOT NULL,
    Phone VARCHAR(15) UNIQUE NOT NULL,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS Categories (
    CategoryID INT GENERATED BY DEFAULT AS IDENTITY(NO CACHE) PRIMARY KEY,
    CategoryName VARCHAR(255) NOT NULL UNIQUE,
    IsDefault BOOLEAN NOT NULL DEFAULT FALSE, -- TRUE for default categories
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS Mode_of_Payment (
    PaymentID INT GENERATED BY DEFAULT AS IDENTITY(NO CACHE) PRIMARY KEY,
    PaymentName VARCHAR(255) NOT NULL UNIQUE,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS Expenses (
    ExpenseID INT GENERATED BY DEFAULT AS IDENTITY(NO CACHE) PRIMARY KEY,
    ExpenseName VARCHAR(50)NOT NULL;
    UserID INT NOT NULL,
    Amount DECIMAL(10, 2) NOT NULL,
    Type VARCHAR(100),
    Payee VARCHAR(100),
    CategoryID INT,
    PaymentID INT, -- Payment mode
    Status ENUM('Active', 'Inactive') DEFAULT 'Active',
    ReferenceID VARCHAR(100) UNIQUE, -- Cheque number/transaction reference
    Description VARCHAR(255),
    Date DATE NOT NULL,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE,
    FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID),
    FOREIGN KEY (PaymentID) REFERENCES Mode_of_Payment(PaymentID)
);

CREATE TABLE IF NOT EXISTS UserCategories (
    UserCategoryID INT GENERATED BY DEFAULT AS IDENTITY(NO CACHE) PRIMARY KEY,      -- Primary key to uniquely identify each record
    UserID INT NOT NULL,                                -- Foreign key to Users table
    CategoryID INT NOT NULL,                            -- Foreign key to Categories table
    IsDefault BOOLEAN NOT NULL DEFAULT FALSE,           -- Flag to mark a default category
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    Status Boolean DEFAULT FALSE,     -- Timestamp for when the record was created
    FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE,     -- Foreign key with cascade delete
    FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID) ON DELETE CASCADE,  -- Foreign key with cascade delete
    CONSTRAINT UC_UserCategory UNIQUE (UserID, CategoryID)  -- Ensure uniqueness of (UserID, CategoryID) combination
);





MERGE INTO Categories AS t
USING (VALUES
    ('All', TRUE),
    ('Housing', TRUE),
    ('Transportation', TRUE),
    ('Utilities', TRUE),
    ('Food', TRUE),
    ('Child Expenses', TRUE),
    ('Health Care', TRUE),
    ('Insurance', TRUE),
    ('Taxes', TRUE),
    ('Entertainment', TRUE),
    ('Miscellaneous', TRUE),
    ('Income', TRUE)
) AS s(CategoryName, IsDefault)
ON t.CategoryName = s.CategoryName
WHEN MATCHED THEN UPDATE SET t.IsDefault = s.IsDefault
WHEN NOT MATCHED THEN INSERT (CategoryName, IsDefault) VALUES (s.CategoryName, s.IsDefault);

MERGE INTO Mode_of_Payment (PaymentName)
KEY (PaymentName)
VALUES
('All'),
('General'),
('UPI'),
('Credit Card'),
('Debit Card'),
('Cash'),
('Net Banking'),
('Cheque');


Both of these SQL queries serve different purposes, but their goal is to insert default categories into the UserCategories table based on the given user.

1. First Query: Inserting for a specific user (UserID = 4)
sql
Copy code
INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
SELECT u.UserID, c.CategoryID, TRUE
FROM Users u
CROSS JOIN Categories c
WHERE u.UserID = 4
  AND c.IsDefault = TRUE;
Explanation:

Purpose: This query will insert default categories (IsDefault = TRUE) for a specific user (in this case, UserID = 4).
Mechanism: It uses a CROSS JOIN to combine every row from Users and Categories, but only inserts data for the specific user (u.UserID = 4) and only for default categories (c.IsDefault = TRUE).
Consideration: This is a one-time insert for a user with UserID = 4 and may need to be adjusted manually for other users.
When to use: This query is useful when you want to add default categories only for a specific user. You'd run this once for every new user who needs to be assigned the default categories.

2. Second Query: Avoiding duplicate inserts
sql
Copy code
INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
SELECT NEW.UserID, c.CategoryID, TRUE
FROM Categories c
WHERE c.IsDefault = TRUE
  AND NOT EXISTS (
    SELECT 1
    FROM UserCategories uc
    WHERE uc.UserID = NEW.UserID
      AND uc.CategoryID = c.CategoryID
  );
Explanation:

Purpose: This query will insert default categories (IsDefault = TRUE) for the user identified by NEW.UserID, but it will only insert categories that the user hasn't already been assigned (avoiding duplicate rows).
Mechanism: It checks for the existence of the user-category combination in the UserCategories table and ensures no duplicates by using a NOT EXISTS clause. If the user doesn't already have a category, it will insert it.
Consideration: This is typically used in a trigger (e.g., after inserting a user) where NEW.UserID refers to the UserID of a newly created user.
When to use: This query is ideal in the context of a trigger, ensuring that new users are assigned the default categories while avoiding the duplication of already existing combinations.

Which to Prefer?
If you are inserting default categories for a specific user (like during a data migration or an admin function), the first query is sufficient. It's designed for a one-time action for a single user.

If you are implementing this logic for a new user insertion dynamically (and you want to do this automatically when a user is created without duplicates), the second query is better because it checks for duplicate entries, making the process more flexible and scalable.

Summary:
First Query: Use it when you know which specific user needs to have the default categories.
Second Query: Use it if you want an automated approach (e.g., within a trigger) where the system automatically adds default categories for any user without inserting duplicates.



INSERT INTO Users (Username, Password, Email, Phone)
VALUES ('User1', 'password123', 'user1@example.com', '1234567890'),
       ('User2', 'password456', 'user2@example.com', '0987654321');

INSERT INTO Categories (CategoryName, IsDefault) VALUES ('Stocks', FALSE);

INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
VALUES (1, (SELECT CategoryID FROM Categories WHERE CategoryName = 'Stocks'), FALSE);


SELECT C.CategoryName
FROM Categories C
INNER JOIN UserCategories UC ON C.CategoryID = UC.CategoryID
WHERE UC.UserID = 1;

INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
SELECT u.UserID, c.CategoryID, TRUE
FROM Users u
CROSS JOIN Categories c
WHERE u.UserID = 4
  AND c.IsDefault = TRUE; ---

INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
SELECT U.UserID, C.CategoryID, TRUE
FROM Users U
CROSS JOIN Categories C
WHERE C.IsDefault = TRUE
  AND NOT EXISTS (
      SELECT 1 FROM UserCategories UC
      WHERE UC.UserID = U.UserID AND UC.CategoryID = C.CategoryID
  );
Assign Categories Manually with SQL
You can use the following query after inserting a user:

sql
Copy code
INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
SELECT u.UserID, c.CategoryID, TRUE
FROM Users u
CROSS JOIN Categories c
WHERE u.UserID = ? -- Replace with the newly created UserID
  AND c.IsDefault = TRUE;
Replace the ? with the specific UserID (typically, the ID of the newly inserted user).

ALTER TABLE UserCategories
ADD CONSTRAINT UC_UserCategory UNIQUE (UserID, CategoryID);

SELECT * FROM UserCategories WHERE UserID = 4

Adjust Insert Logic to Prevent Duplicates
Use INSERT ... SELECT with a condition to exclude existing records. Here's the query to insert default categories for a new user:

sql
Copy code
INSERT INTO UserCategories (UserID, CategoryID, IsDefault)
SELECT NEW.UserID, c.CategoryID, TRUE
FROM Categories c
WHERE c.IsDefault = TRUE
  AND NOT EXISTS (
    SELECT 1
    FROM UserCategories uc
    WHERE uc.UserID = NEW.UserID
      AND uc.CategoryID = c.CategoryID
  );

In an expense tracker application, the Expense Name, Description, and Categories are used to organize, identify, and describe the expenses more clearly. Here’s an example of how they function:

1. Expense Name:

The Expense Name is typically the title or label for the expense. It helps users easily identify the type of expense they’re adding.

Example:
Expense Name: "Grocery Shopping"

2. Description:

The Description provides additional information about the expense. It's a free-text field where the user can explain the expense in detail.

Example:
Description: "Bought groceries for the week including vegetables, fruits, and snacks."

3. Categories:

Categories allow users to organize their expenses into different groups. This helps track spending in different areas, such as food, travel, bills, etc. Categories are useful for filtering and reporting purposes.

Example:
Category: "Food"
(Here, grocery shopping falls under the "Food" category.)


---

Putting it all together in an example:

If a user adds a new expense:

Expense Name: "Grocery Shopping"

Category: "Food"

Description: "Bought groceries for the week including vegetables, fruits, and snacks."

Amount: 50.00 (currency value)


This information helps the user track where and how much they are spending on food items, and if they choose to generate a report, the expense can be filtered under the "Food" category for analysis.

